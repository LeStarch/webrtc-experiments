/**
 * Functions that attach WebRTC functions to the side-channel messaging neeeded handle ICE
 * 
 * WebRTC peers need a side channel to transmit messages that setup the WebRTC peer-to-peer
 * connection. Somewhat internally to the WebRTC protocol, ICE candidate messages that propose a
 * possible connection between WebRTC peers need to be passed back-and-forth. These messages are
 * generated from and consumed by WebRTC peers but the message passing is via the side channel.
 * 
 * The functions in this file abstract away this ICE layer by attaching the side-channel functions
 * defined in lib/fetcher.js to the WebRTC functions defined in lib/rtc.js such that WebRTC ICE
 * candidate messages are shuttled behind the scenes.
 * 
 * @author LeStarch
 */
import { createPeerConnection } from "../lib/rtc.js";
import { pollIce, sendIce } from "../lib/fetcher.js";

/**
 * Set-up WebRTC peer, affiliated data, and begin handling ICE candidate events
 * 
 * In order for messages to pass between WebRTC peers, several concepts need to be established: an
 * identity for this peer, a placeholder for the eventual remote peer, and the peer connection
 * object. Once these concepts are established, ICE events from the local peer must trigger a
 * message to the client message server, and incoming ICE messages must be POLLed from the same
 * server.
 * 
 * The peer and ID objects are created. An ICE POLLer is started to find remote ICE candidate
 * messages and an ICE event listener is registered to pass local ICE candidate messages down
 * to the server.
 * 
 * @returns {Object}: object with peer, local peer id, remote peer id, and ICE POLLer ID fields.
 */
export function setupPeerData() {
    let [peer, peer_id] = createPeerConnection();

    let data = {
        peer: peer,
        peer_id: peer_id,
        remote_id: null,
        ice_poll_id: null,
        ice_candidates: []
    }
    data.ice_poll_id = setInterval(icePoller.bind(undefined, data), 200);
    peer.addEventListener("icecandidate", iceCandidateSender.bind(undefined, data.peer_id));
    return data;
}

/**
 * Handle a local ICE candidate event by sending it to the client managing server
 * 
 * Local ICE candidate connections are produced as an event registered to the local WebRTC peer.
 * These events are handeled by this callback and are passed to the client managing server via the
 * sendIce function using the local peer ID.
 * 
 * Note: this function is intended as peer-id-bound event handler for "icecandidate" events
 * produced by the local WebRTC peer.  i.e.
 * 
 * ```
 * peer.addEventListener("icecandidate", iceCandidateSender.bind(undefined, peer_id));
 * ```
 * 
 * @param {string} peer_id: local peer id as provided by setupPeerData.
 * @param {*} event: ICE candidate event generated by the peer object associated with the peer ID
 */
async function iceCandidateSender(peer_id, event) {
    if (event.candidate) {
        await sendIce(peer_id, event.candidate);
    }
}

/**
 * POLL and handle ICE candidate messages once the remote candidate is established
 * 
 * In order to finalize the connection between WebRTC candidates, ICE candidate messages need to be
 * received from the client managing server and handed back to the WebRTC peer. This is
 * accomplished by POLLing the client managing server for ICE candidate messages from the remote
 * peer ID. Once these messages are received they are supplied to the local peer.
 * 
 * Note: this function is intended to be setup to POLL on a quick timed interval (< 1 second) in
 * order to receive and handle messages before the ICE connection timeout terminates the
 * connection.
 * 
 * Note 2: data is bound in as an object such that changes to remote-id are tracked as a raw
 * reference would not track the update. This implies that the function does nothing until the
 * remote ID is set.
 * 
 * @param {Object} data: defining remote_id field eventually set to remote client ID and peer
 *     field set to the local peer object.
 */
async function icePoller(data) {
    if (!data.remote_id) {
        return;
    }
    let [success, messages] = await pollIce(data.remote_id);
    if (!success) {
        return;
    }
    // Push received ICE candidates to the local peer
    await messages.forEach(async (candidate) => {
        try {
            let candidate_string = JSON.stringify(candidate);
            if (data.ice_candidates.indexOf(candidate_string) == -1) {
                data.ice_candidates.push(candidate_string);
                await data.peer.addIceCandidate(new RTCIceCandidate(candidate));
            }
        } catch (e) {
            console.error("Failed to add ICE candidate:", e);
        }
    });
}